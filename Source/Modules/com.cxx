/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * com.cxx
 *
 * COM module for SWIG.
 * ----------------------------------------------------------------------------- */

char cvsroot_com_cxx[] = "$Id$";

#include "swigmod.h"
#include "cparse.h"

class COM:public Language {
  static const char *usage;

  File *f_runtime;
  File *f_header;
  File *f_module;

  bool proxy_flag;		// Flag for generating proxy classes
  bool enum_constant_flag;	// Flag for when wrapping an enum or constant

  String *module_class_name;	// module class name
  String *module_class_code;

public:

  /* -----------------------------------------------------------------------------
   * COM()
   * ----------------------------------------------------------------------------- */

  COM():proxy_flag(true),
      enum_constant_flag(false) {
    /* Empty for now */
  }

  /* ------------------------------------------------------------
   * main()
   * ------------------------------------------------------------ */

  virtual void main(int argc, char *argv[]) {

    SWIG_library_directory("com");

    // Look for certain command line options
    for (int i = 1; i < argc; i++) {
      if (argv[i]) {
	if (strcmp(argv[i], "-help") == 0) {
	  Printf(stdout, "%s\n", usage);
	}
      }
    }
    // Add a symbol to the parser for conditional compilation
    Preprocessor_define("SWIGCOM 1", 0);

    // Add typemap definitions
    SWIG_typemap_lang("com");
    SWIG_config_file("com.swg");

    allow_overloading();
  }

  /* ---------------------------------------------------------------------
   * top()
   * --------------------------------------------------------------------- */

  virtual int top(Node *n) {

    /* Initialize all of the output files */
    String *outfile = Getattr(n, "outfile");
    String *outfile_h = Getattr(n, "outfile_h");

    if (!outfile) {
      Printf(stderr, "Unable to determine outfile\n");
      SWIG_exit(EXIT_FAILURE);
    }

    f_runtime = NewFile(outfile, "w");
    if (!f_runtime) {
      FileErrorDisplay(outfile);
      SWIG_exit(EXIT_FAILURE);
    }

    f_header = NewString("");

    /* Register file targets with the SWIG file handler */
    Swig_register_filebyname("header", f_header);
    Swig_register_filebyname("runtime", f_runtime);

    /* FIXME: do it as it is done in other targets */
    module_class_name = Copy(Getattr(n, "name"));

    module_class_code = NewString("");

    /* Emit code */
    Language::top(n);

    /* Generate the IDL file containing the module class and proxy classes */
    {
      String *filen = NewStringf("%s%s.idl", SWIG_output_directory(), module_class_name);
      f_module = NewFile(filen, "w");
      if (!f_module) {
	FileErrorDisplay(filen);
	SWIG_exit(EXIT_FAILURE);
      }
      // Append(filenames_list, Copy(filen));
      Delete(filen);
      filen = NULL;

      // Banner for the IDL file
      emitBanner(f_module);

      // Standard imports
      Printf(f_module, "import \"unknwn.idl\";\n");
      Printf(f_module, "\n");

      // Interface for module class
      // TODO: UUIDs, etc. object & local for now to silence IDL compiler ;)
      Printf(f_module, "[\n  object,\n  local\n]\ninterface %s : IUnknown {\n", module_class_name);

      // Add the wrapper methods
      Printv(f_module, module_class_code, NIL);

      Printf(f_module, "};\n");
    }

    /* Close all of the files */
    Dump(f_header, f_runtime);
    Delete(f_header);
    Delete(f_runtime);
    Delete(f_module);
    return SWIG_OK;
  }

  /* -----------------------------------------------------------------------------
   * emitBanner()
   * ----------------------------------------------------------------------------- */

  void emitBanner(File *f) {
    Printf(f, "/* ----------------------------------------------------------------------------\n");
    Printf(f, " * This file was automatically generated by SWIG (http://www.swig.org).\n");
    Printf(f, " * Version %s\n", Swig_package_version());
    Printf(f, " *\n");
    Printf(f, " * Do not make changes to this file unless you know what you are doing--modify\n");
    Printf(f, " * the SWIG interface file instead.\n");
    Printf(f, " * ----------------------------------------------------------------------------- */\n\n");
  }

  /* -----------------------------------------------------------------------------
   * functionWrapper()
   * ----------------------------------------------------------------------------- */

  virtual int functionWrapper(Node *n) {
    ParmList *l = Getattr(n, "parms");

    /* FIXME: temporary, will be done by emit_attach_parmmaps in the future */
    Swig_typemap_attach_parms("in", l, NULL);

    if (!(proxy_flag && is_wrapping_class()) && !enum_constant_flag) {
      moduleClassFunctionHandler(n);
    }

    return SWIG_OK;
  }

  /* -----------------------------------------------------------------------------
   * moduleClassFunctionHandler()
   * ----------------------------------------------------------------------------- */

  int moduleClassFunctionHandler(Node *n) {
    SwigType *t = Getattr(n, "type");
    ParmList *l = Getattr(n, "parms");
    String *tm;
    String *return_type = NewString("");
    String *function_code = NewString("");
    Parm *p;
    int i;

    if (l) {
      if (SwigType_type(Getattr(l, "type")) == T_VOID) {
	l = nextSibling(l);
      }
    }

    /* Attach the non-standard typemaps to the parameter list */
    Swig_typemap_attach_parms("comtype", l, NULL);
    Swig_typemap_attach_parms("comin", l, NULL);

    /* Get return types */
    if ((tm = Swig_typemap_lookup("comtype", n, "", 0))) {
      String *comtypeout = Getattr(n, "tmap:comtype:out");	// the type in the comtype typemap's out attribute overrides the type in the typemap
      if (comtypeout)
	tm = comtypeout;
      // JJ: if the typemap contains $comclassname substitute it with the actual class
      //substituteClassname(t, tm);
      Printf(return_type, "%s", tm);
    } else {
      Swig_warning(WARN_CSHARP_TYPEMAP_CSWTYPE_UNDEF, input_file, line_number, "No comtype typemap defined for %s\n", SwigType_str(t, 0));
    }

    Printf(function_code, "  %s %s(", return_type, Getattr(n, "sym:name"));

    /* Get number of required and total arguments */
    int num_arguments = emit_num_arguments(l);
    int num_required = emit_num_required(l);

    int gencomma = 0;

    /* Output each parameter */
    for (i = 0, p = l; i < num_arguments; i++) {

      /* Ignored parameters */
      while (checkAttribute(p, "tmap:in:numinputs", "0")) {
	p = Getattr(p, "tmap:in:next");
      }

      SwigType *pt = Getattr(p, "type");
      String *param_type = NewString("");

      /* Get the COM parameter type */
      if ((tm = Getattr(p, "tmap:comtype"))) {
	// substituteClassname(pt, tm);
	Printf(param_type, "%s", tm);
      } else {
	Swig_warning(WARN_CSHARP_TYPEMAP_CSWTYPE_UNDEF, input_file, line_number, "No comtype typemap defined for %s\n", SwigType_str(pt, 0));
      }

      String *arg = NewStringf("arg%d", i);

      /* Add parameter to module class function */
      if (gencomma >= 2)
	Printf(function_code, ", ");
      gencomma = 2;
      Printf(function_code, "%s %s", param_type, arg);

      p = Getattr(p, "tmap:in:next");
      Delete(arg);
      Delete(param_type);
    }

    Printf(function_code, ");\n");

    Printv(module_class_code, function_code, NIL);
    Delete(function_code);
    Delete(return_type);

    return SWIG_OK;
  }

};				/* class COM */

/* -----------------------------------------------------------------------------
 * swig_com()    - Instantiate module
 * ----------------------------------------------------------------------------- */

static Language *new_swig_com() {
  return new COM();
}
extern "C" Language *swig_com(void) {
  return new_swig_com();
}

/* -----------------------------------------------------------------------------
 * Static member variables
 * ----------------------------------------------------------------------------- */

const char *COM::usage = (char *) "\
COM Options (available with -com)\n\
\n";
